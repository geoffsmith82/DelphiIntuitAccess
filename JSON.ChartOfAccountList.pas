unit JSON.ChartOfAccountList;

//  *************************************************
//    Generated By: JsonToDelphiClass - 0.65
//    Project link: https://github.com/PKGeorgiev/Delphi-JsonToDelphiClass
//    Generated On: 2019-05-22 20:38:03
//  *************************************************
//    Created By  : Petar Georgiev - 2014
//    WebSite     : http://pgeorgiev.com
//  *************************************************

interface

uses
    Generics.Collections
  , Rest.Json
  , REST.JSON.Types
  ;

type

TMetaDataClass = class
private
  FCreateTime: String;
  FLastUpdatedTime: String;
public
  property CreateTime: String read FCreateTime write FCreateTime;
  property LastUpdatedTime: String read FLastUpdatedTime write FLastUpdatedTime;
  function ToJsonString: string;
  class function FromJsonString(AJsonString: string): TMetaDataClass;
end;

TCurrencyRefClass = class
private
  FName: String;
  FValue: String;
public
  property name: String read FName write FName;
  property value: String read FValue write FValue;
  function ToJsonString: string;
  class function FromJsonString(AJsonString: string): TCurrencyRefClass;
end;

TAccountClass = class
private
  FAccountSubType: String;
  FAccountType: String;
  FActive: Boolean;
  FClassification: String;
  FCurrencyRef: TCurrencyRefClass;
  FCurrentBalance: Extended;
  FCurrentBalanceWithSubAccounts: Extended;
  FDescription: String;
  FFullyQualifiedName: String;
  FId: String;
  FMetaData: TMetaDataClass;
  FName: String;
  FSubAccount: Boolean;
  FSyncToken: String;
  FDomain: String;
  FSparse: Boolean;
public
  property AccountSubType: String read FAccountSubType write FAccountSubType;
  property AccountType: String read FAccountType write FAccountType;
  property Active: Boolean read FActive write FActive;
  property Classification: String read FClassification write FClassification;
  property CurrencyRef: TCurrencyRefClass read FCurrencyRef write FCurrencyRef;
  property CurrentBalance: Extended read FCurrentBalance write FCurrentBalance;
  property CurrentBalanceWithSubAccounts: Extended read FCurrentBalanceWithSubAccounts write FCurrentBalanceWithSubAccounts;
  property Description: String read FDescription write FDescription;
  property FullyQualifiedName: String read FFullyQualifiedName write FFullyQualifiedName;
  property Id: String read FId write FId;
  property MetaData: TMetaDataClass read FMetaData write FMetaData;
  property Name: String read FName write FName;
  property SubAccount: Boolean read FSubAccount write FSubAccount;
  property SyncToken: String read FSyncToken write FSyncToken;
  property domain: String read FDomain write FDomain;
  property sparse: Boolean read FSparse write FSparse;
  constructor Create;
  destructor Destroy; override;
  function ToJsonString: string;
  class function FromJsonString(AJsonString: string): TAccountClass;
end;

TQueryResponseClass = class
private
  FAccount: TArray<TAccountClass>;
  FMaxResults: Extended;
  FStartPosition: Extended;
public
  property Account: TArray<TAccountClass> read FAccount write FAccount;
  property maxResults: Extended read FMaxResults write FMaxResults;
  property startPosition: Extended read FStartPosition write FStartPosition;
  destructor Destroy; override;
  function ToJsonString: string;
  class function FromJsonString(AJsonString: string): TQueryResponseClass;
end;

TJSONChartOfAccountListClass = class
private
  FQueryResponse: TQueryResponseClass;
  FTime: String;
public
  property QueryResponse: TQueryResponseClass read FQueryResponse write FQueryResponse;
  property time: String read FTime write FTime;
  constructor Create;
  destructor Destroy; override;
  function ToJsonString: string;
  class function FromJsonString(AJsonString: string): TJSONChartOfAccountListClass;
end;

implementation

{TMetaDataClass}


function TMetaDataClass.ToJsonString: string;
begin
  result := TJson.ObjectToJsonString(self);
end;

class function TMetaDataClass.FromJsonString(AJsonString: string): TMetaDataClass;
begin
  result := TJson.JsonToObject<TMetaDataClass>(AJsonString)
end;

{TCurrencyRefClass}


function TCurrencyRefClass.ToJsonString: string;
begin
  result := TJson.ObjectToJsonString(self);
end;

class function TCurrencyRefClass.FromJsonString(AJsonString: string): TCurrencyRefClass;
begin
  result := TJson.JsonToObject<TCurrencyRefClass>(AJsonString)
end;

{TAccountClass}

constructor TAccountClass.Create;
begin
  inherited;
  FCurrencyRef := TCurrencyRefClass.Create();
  FMetaData := TMetaDataClass.Create();
end;

destructor TAccountClass.Destroy;
begin
  FCurrencyRef.free;
  FMetaData.free;
  inherited;
end;

function TAccountClass.ToJsonString: string;
begin
  result := TJson.ObjectToJsonString(self);
end;

class function TAccountClass.FromJsonString(AJsonString: string): TAccountClass;
begin
  result := TJson.JsonToObject<TAccountClass>(AJsonString)
end;

{TQueryResponseClass}

destructor TQueryResponseClass.Destroy;
var
  LAccountItem: TAccountClass;
begin

 for LAccountItem in FAccount do
   LAccountItem.free;

  inherited;
end;

function TQueryResponseClass.ToJsonString: string;
begin
  result := TJson.ObjectToJsonString(self);
end;

class function TQueryResponseClass.FromJsonString(AJsonString: string): TQueryResponseClass;
begin
  result := TJson.JsonToObject<TQueryResponseClass>(AJsonString)
end;

{TRootClass}

constructor TJSONChartOfAccountListClass.Create;
begin
  inherited;
  FQueryResponse := TQueryResponseClass.Create();
end;

destructor TJSONChartOfAccountListClass.Destroy;
begin
  FQueryResponse.free;
  inherited;
end;

function TJSONChartOfAccountListClass.ToJsonString: string;
begin
  result := TJson.ObjectToJsonString(self);
end;

class function TJSONChartOfAccountListClass.FromJsonString(AJsonString: string): TJSONChartOfAccountListClass;
begin
  result := TJson.JsonToObject<TJSONChartOfAccountListClass>(AJsonString)
end;

end.

